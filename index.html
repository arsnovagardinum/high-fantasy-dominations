<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>High Fantasy Dominations - Isometric</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{margin:0;overflow:hidden;background:#1a2f28;font-family:'Arial',sans-serif}
#gameCanvas{display:block}
#loading{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.95);padding:40px;border-radius:15px;border:3px solid #ffd700;text-align:center;z-index:3000;color:#fff;min-width:400px}
#loading h2{color:#ffd700;margin-bottom:20px;font-family:'Cinzel',serif}
.progress-bar{width:300px;height:20px;background:rgba(255,255,255,0.1);border-radius:10px;overflow:hidden;margin:20px 0}
.progress-fill{height:100%;background:linear-gradient(90deg,#ffd700,#ffed4e);width:0%;transition:width 0.3s}
#ui{position:fixed;top:10px;left:10px;background:rgba(0,0,0,0.8);padding:15px;border-radius:10px;color:#fff;font-family:'Cinzel',serif;z-index:1000}
.asset-status{position:fixed;bottom:10px;right:10px;background:rgba(0,0,0,0.8);padding:10px;border-radius:8px;color:#fff;font-size:12px;z-index:1000;max-height:200px;overflow-y:auto}
.status-ok{color:#0f0}
.status-error{color:#f00}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<div id="loading">
  <h2>‚öîÔ∏è Loading Assets...</h2>
  <div class="progress-bar"><div class="progress-fill" id="progress"></div></div>
  <p id="loading-text">Initializing...</p>
</div>

<div id="ui" style="display:none">
  <div>ü™ô Gold: <span id="gold">800</span></div>
  <div>üíé Mana: <span id="mana">150</span></div>
  <div style="margin-top:10px;font-size:12px">Right-click drag to pan</div>
</div>

<div id="asset-status" class="asset-status" style="display:none">
  <div style="font-weight:bold;margin-bottom:8px">üì¶ Asset Status:</div>
  <div id="status-list"></div>
</div>

<script>
// ==================== CONFIGURATION ====================
const GITHUB_USER = 'arsnovagardinum';
const REPO = 'high-fantasy-dominations';
const BRANCH = 'main';

// BASE ASSET PATHS - Add new building types here only
const ASSET_PATHS = {
  buildings: [
    'town_core',
    'gold_mine',
    'mana_well',
    'farm',
    'barracks',
    'arrow_tower',
    'cannon_tower'
  ],
  terrain: [
    'grass_tile',
    'tree_oak_medium',
    'rock_medium'
  ]
};

function getAssetURL(path) {
  return `https://cdn.jsdelivr.net/gh/${GITHUB_USER}/${REPO}@${BRANCH}/${path}`;
}

// ==================== ISOMETRIC SETTINGS ====================
const ISO = {
  tileWidth: 128,
  tileHeight: 64,
  gridSize: 35
};

// ==================== GAME STATE ====================
const State = {
  gold: 800,
  mana: 150,
  buildings: [
    {x: 14, y: 14, type: 'town_core'},
    {x: 10, y: 16, type: 'gold_mine'},
    {x: 18, y: 16, type: 'mana_well'}
  ],
  camera: {x: 0, y: 0},
  assets: {},
  assetsLoaded: 0,
  totalAssets: 0,
  assetStatus: []
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// ==================== SMART ASSET LOADER ====================
function loadAsset(name, path, category) {
  return new Promise((resolve) => {
    const img = new Image();
    const url = getAssetURL(path);
    
    img.onload = () => {
      State.assetsLoaded++;
      State.assetStatus.push({name, status: 'ok'});
      console.log(`‚úÖ Loaded: ${name}`);
      updateProgress();
      resolve({name, img, success: true});
    };
    
    img.onerror = () => {
      State.assetsLoaded++;
      State.assetStatus.push({name, status: 'error', url});
      console.warn(`‚ö†Ô∏è Missing: ${name}\nURL: ${url}`);
      updateProgress();
      resolve({name, img: null, success: false});
    };
    
    img.src = url;
  });
}

function updateProgress() {
  const percent = (State.assetsLoaded / State.totalAssets) * 100;
  document.getElementById('progress').style.width = percent + '%';
  document.getElementById('loading-text').innerText = 
    `Loaded ${State.assetsLoaded}/${State.totalAssets} assets...`;
}

async function loadAllAssets() {
  const promises = [];
  
  // Count total assets
  State.totalAssets = ASSET_PATHS.buildings.length + ASSET_PATHS.terrain.length;
  
  // Load all buildings
  ASSET_PATHS.buildings.forEach(name => {
    promises.push(loadAsset(name, `assets/buildings/${name}.png`, 'buildings'));
  });
  
  // Load all terrain
  ASSET_PATHS.terrain.forEach(name => {
    promises.push(loadAsset(name, `assets/terrain/${name}.png`, 'terrain'));
  });
  
  // Wait for all
  const loaded = await Promise.all(promises);
  
  // Store loaded assets
  loaded.forEach(({name, img, success}) => {
    if (success && img) {
      State.assets[name] = img;
    }
  });
  
  // Show asset status
  showAssetStatus();
  
  // Start game
  setTimeout(() => {
    document.getElementById('loading').style.display = 'none';
    document.getElementById('ui').style.display = 'block';
    initGame();
  }, 500);
}

function showAssetStatus() {
  const statusDiv = document.getElementById('asset-status');
  const listDiv = document.getElementById('status-list');
  
  State.assetStatus.forEach(asset => {
    const div = document.createElement('div');
    div.innerHTML = asset.status === 'ok' 
      ? `<span class="status-ok">‚úÖ</span> ${asset.name}`
      : `<span class="status-error">‚ùå</span> ${asset.name}`;
    listDiv.appendChild(div);
  });
  
  statusDiv.style.display = 'block';
  
  // Auto-hide after 5 seconds
  setTimeout(() => {
    statusDiv.style.display = 'none';
  }, 5000);
}

// ==================== ISOMETRIC FUNCTIONS ====================
function isoToScreen(gridX, gridY) {
  return {
    x: (gridX - gridY) * ISO.tileWidth / 2 + canvas.width / 2 + State.camera.x,
    y: (gridX + gridY) * ISO.tileHeight / 2 + canvas.height / 2 + State.camera.y
  };
}

function drawIsometricTile(gridX, gridY, color) {
  const pos = isoToScreen(gridX, gridY);
  
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(pos.x, pos.y);
  ctx.lineTo(pos.x + ISO.tileWidth / 2, pos.y + ISO.tileHeight / 2);
  ctx.lineTo(pos.x, pos.y + ISO.tileHeight);
  ctx.lineTo(pos.x - ISO.tileWidth / 2, pos.y + ISO.tileHeight / 2);
  ctx.closePath();
  ctx.fill();
  
  ctx.strokeStyle = 'rgba(0,0,0,0.15)';
  ctx.lineWidth = 1;
  ctx.stroke();
}

function drawIsometricSprite(gridX, gridY, asset, footprintW = 1, footprintH = 1) {
  if (!asset) return;
  
  const pos = isoToScreen(gridX, gridY);
  const offsetX = (footprintW - 1) * ISO.tileWidth / 2;
  const offsetY = (footprintH - 1) * ISO.tileHeight / 2;
  
  const drawX = pos.x - asset.width / 2 - offsetX;
  const drawY = pos.y - asset.height + ISO.tileHeight / 2 - offsetY;
  
  ctx.drawImage(asset, drawX, drawY);
}

function getBuildingFootprint(type) {
  const footprints = {
    town_core: {w: 6, h: 6},
    gold_mine: {w: 4, h: 4},
    mana_well: {w: 4, h: 4},
    farm: {w: 4, h: 4},
    barracks: {w: 5, h: 5},
    arrow_tower: {w: 3, h: 3},
    cannon_tower: {w: 3, h: 3}
  };
  return footprints[type] || {w: 1, h: 1};
}

function drawBuilding(b) {
  const asset = State.assets[b.type];
  const footprint = getBuildingFootprint(b.type);
  
  // Draw foundation
  for (let x = 0; x < footprint.w; x++) {
    for (let y = 0; y < footprint.h; y++) {
      drawIsometricTile(b.x + x, b.y + y, '#3d5a4a');
    }
  }
  
  // Draw sprite (or fallback if missing)
  if (asset) {
    drawIsometricSprite(b.x, b.y, asset, footprint.w, footprint.h);
  } else {
    // Fallback: Draw colored rectangle
    const pos = isoToScreen(b.x, b.y);
    ctx.fillStyle = '#666';
    ctx.fillRect(pos.x - 20, pos.y - 40, 40, 60);
    ctx.fillStyle = '#fff';
    ctx.font = '12px Arial';
    ctx.fillText('Missing Asset', pos.x - 35, pos.y - 50);
  }
}

function drawTerrain(gridX, gridY) {
  const grassAsset = State.assets.grass_tile;
  const pos = isoToScreen(gridX, gridY);
  
  if (grassAsset) {
    ctx.drawImage(grassAsset, pos.x - 64, pos.y - 32, 128, 64);
  } else {
    drawIsometricTile(gridX, gridY, '#3d5a4a');
  }
}

// ==================== GAME LOOP ====================
function gameLoop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  const startCol = Math.floor((-State.camera.x + canvas.width/2) / (ISO.tileWidth/2)) - 2;
  const endCol = startCol + (canvas.width / (ISO.tileWidth/2)) + 4;
  const startRow = Math.floor((-State.camera.y + canvas.height/2) / (ISO.tileHeight/2)) - 2;
  const endRow = startRow + (canvas.height / (ISO.tileHeight/2)) + 4;
  
  // Draw terrain
  for (let c = Math.max(0, startCol); c < Math.min(ISO.gridSize, endCol); c++) {
    for (let r = Math.max(0, startRow); r < Math.min(ISO.gridSize, endRow); r++) {
      drawTerrain(c, r);
    }
  }
  
  // Draw buildings (sorted by Y for depth)
  const sorted = [...State.buildings].sort((a, b) => {
    const posA = isoToScreen(a.x + 3, a.y + 3);
    const posB = isoToScreen(b.x + 3, b.y + 3);
    return posA.y - posB.y;
  });
  
  sorted.forEach(b => drawBuilding(b));
  
  requestAnimationFrame(gameLoop);
}

// ==================== INIT ====================
function initGame() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  
  const tcPos = isoToScreen(17, 17);
  State.camera.x = -tcPos.x + canvas.width / 2;
  State.camera.y = -tcPos.y + canvas.height / 2 + 100;
  
  gameLoop();
}

// ==================== CONTROLS ====================
let isPanning = false;
let lastMouse = {x: 0, y: 0};

canvas.addEventListener('mousedown', e => {
  if (e.button === 2) {
    isPanning = true;
    lastMouse = {x: e.clientX, y: e.clientY};
  }
});

canvas.addEventListener('mousemove', e => {
  if (isPanning) {
    State.camera.x += e.clientX - lastMouse.x;
    State.camera.y += e.clientY - lastMouse.y;
    lastMouse = {x: e.clientX, y: e.clientY};
  }
});

canvas.addEventListener('mouseup', () => isPanning = false);
canvas.addEventListener('contextmenu', e => e.preventDefault());

window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
});

// ==================== START ====================
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
loadAllAssets();
</script>
</body>
</html>
